const e={basics:{name:"Java 8 Basics",color:"#4CAF50",description:"Lambda expressions, functional interfaces, method references, and basic stream operations"},intermediate:{name:"Java 8 Intermediate",color:"#FF9800",description:"Stream API, collectors, Optional class, and advanced functional programming"},expert:{name:"Java 8 Expert",color:"#F44336",description:"Advanced streams, CompletableFuture, parallel processing, and Date/Time API"}},t=[{id:1,question:"What is a lambda expression in Java 8?",answer:"A lambda expression is a concise way to represent an anonymous function that can be passed around. It has the syntax: (parameters) -> expression or (parameters) -> { statements }. Example: (x, y) -> x + y. It enables functional programming style and works with functional interfaces.",category:"basics"},{id:2,question:"What is a functional interface in Java 8?",answer:"A functional interface is an interface with exactly one abstract method (SAM - Single Abstract Method). It can have default and static methods. Examples: Predicate<T>, Function<T,R>, Consumer<T>, Supplier<T>. The @FunctionalInterface annotation ensures the interface has only one abstract method.",category:"basics"},{id:3,question:"What are the built-in functional interfaces in Java 8?",answer:"Key functional interfaces include: Predicate<T> (T -> boolean for testing conditions), Function<T,R> (T -> R for transformations), Consumer<T> (T -> void for side effects), Supplier<T> (() -> T for providing values), UnaryOperator<T> (T -> T), BinaryOperator<T> ((T,T) -> T).",category:"basics"},{id:4,question:"What are method references in Java 8?",answer:"Method references provide a shorthand for lambda expressions that call existing methods. Types: Static method (Class::method), Instance method of specific object (object::method), Instance method of arbitrary object (Class::method), Constructor (Class::new). Example: String::toUpperCase instead of s -> s.toUpperCase().",category:"basics"},{id:5,question:"What is the Stream API in Java 8?",answer:"Stream API provides functional programming approach for processing collections. Streams are not data structures but views of data. They support intermediate operations (filter, map, sorted) and terminal operations (forEach, collect, reduce). Enables concise, readable data processing pipelines.",category:"basics"},{id:6,question:"What is the difference between intermediate and terminal operations in streams?",answer:"Intermediate operations return a new stream and are lazy (not executed until terminal operation). Examples: filter(), map(), sorted(). Terminal operations trigger stream processing and return non-stream result. Examples: forEach(), collect(), reduce(), count(). Streams use lazy evaluation for performance.",category:"basics"},{id:7,question:"How do you create streams in Java 8?",answer:"Streams can be created from: Collections (collection.stream()), Arrays (Arrays.stream(array)), Static methods (Stream.of(1,2,3)), Ranges (IntStream.range(1,10)), Files (Files.lines()), Infinite streams (Stream.iterate(), Stream.generate()).",category:"basics"},{id:8,question:"What is the filter() operation in streams?",answer:"filter() is an intermediate operation that selects elements matching a given predicate. It takes a Predicate<T> and returns a new stream containing only elements for which the predicate returns true. Example: stream.filter(x -> x > 5) keeps only elements greater than 5.",category:"basics"},{id:9,question:"What is the map() operation in streams?",answer:"map() is an intermediate operation that transforms elements using a given function. It takes a Function<T,R> and returns a stream of transformed elements. Example: stream.map(String::toUpperCase) converts all strings to uppercase. It's one-to-one transformation.",category:"basics"},{id:10,question:"What is the forEach() operation in streams?",answer:"forEach() is a terminal operation that performs an action for each element in the stream. It takes a Consumer<T> and returns void. Example: stream.forEach(System.out::println) prints each element. It's used for side effects, not for transformations.",category:"basics"},{id:11,question:"What is the collect() operation in streams?",answer:"collect() is a terminal operation that accumulates stream elements into a collection or other data structure. It uses Collector objects. Common collectors: toList(), toSet(), toMap(), joining(), groupingBy(). Example: stream.collect(Collectors.toList()) creates a list.",category:"basics"},{id:12,question:"What are default methods in Java 8 interfaces?",answer:"Default methods allow interfaces to have method implementations using the 'default' keyword. They enable interface evolution without breaking existing implementations. Example: default void method() { /* implementation */ }. Classes can override default methods or inherit them.",category:"basics"},{id:13,question:"What are static methods in interfaces (Java 8)?",answer:"Java 8 allows static methods in interfaces using the 'static' keyword. These methods belong to the interface, not implementing classes. They're called on the interface itself: Interface.staticMethod(). Useful for utility methods related to the interface.",category:"basics"},{id:14,question:"What is the Optional class in Java 8?",answer:"Optional<T> is a container that may or may not contain a non-null value. It helps avoid NullPointerException by making null handling explicit. Key methods: of(), empty(), ofNullable(), isPresent(), ifPresent(), orElse(), orElseThrow(). Encourages better null-checking practices.",category:"basics"},{id:15,question:"How do you create Optional objects?",answer:"Optional objects are created using: Optional.of(value) - for non-null values (throws NPE if null), Optional.empty() - for empty optional, Optional.ofNullable(value) - handles null safely (returns empty if null). Never use new Optional() directly.",category:"basics"},{id:16,question:"What is the reduce() operation in streams?",answer:"reduce() is a terminal operation that combines stream elements into a single result using a binary operator. Forms: reduce(BinaryOperator), reduce(identity, BinaryOperator), reduce(identity, BiFunction, BinaryOperator). Example: stream.reduce(0, Integer::sum) sums all elements.",category:"basics"},{id:17,question:"What are specialized streams for primitives?",answer:"Java 8 provides IntStream, LongStream, and DoubleStream for primitive types to avoid boxing overhead. They offer specialized methods like sum(), average(), max(), min(). Convert using mapToInt(), mapToLong(), mapToDouble(). Example: stream.mapToInt(String::length).sum().",category:"basics"},{id:18,question:"What is the difference between findFirst() and findAny()?",answer:"Both return Optional<T> but with different guarantees. findFirst() returns the first element in encounter order, deterministic. findAny() returns any element, non-deterministic, optimized for parallel streams. In sequential streams, findAny() usually returns first element.",category:"basics"},{id:19,question:"What are the matching operations in streams?",answer:"Matching operations test stream elements against predicates: allMatch() returns true if all elements match, anyMatch() returns true if any element matches, noneMatch() returns true if no elements match. All are terminal operations returning boolean.",category:"basics"},{id:20,question:"What is the count() operation in streams?",answer:"count() is a terminal operation that returns the number of elements in the stream as a long. It's equivalent to reduce(0, (a, b) -> a + 1) but more efficient. Example: stream.filter(predicate).count() counts elements matching the predicate.",category:"basics"},{id:21,question:"What is the limit() operation in streams?",answer:"limit() is an intermediate operation that truncates the stream to contain at most the specified number of elements. It's useful for pagination or processing partial data. Example: stream.limit(10) keeps only first 10 elements. Short-circuits for infinite streams.",category:"basics"},{id:22,question:"What is the skip() operation in streams?",answer:"skip() is an intermediate operation that discards the first n elements of the stream and returns remaining elements. If stream has fewer elements than n, empty stream is returned. Example: stream.skip(5) skips first 5 elements. Useful for pagination.",category:"basics"},{id:23,question:"What is the distinct() operation in streams?",answer:"distinct() is an intermediate operation that removes duplicate elements from the stream based on equals() method. It returns a stream with unique elements. Example: stream.distinct() removes duplicates. For custom objects, ensure proper equals() and hashCode() implementation.",category:"basics"},{id:24,question:"What is the sorted() operation in streams?",answer:"sorted() is an intermediate operation that sorts stream elements. Two forms: sorted() uses natural ordering (Comparable), sorted(Comparator) uses custom comparator. Example: stream.sorted(Comparator.comparing(Person::getName)) sorts by name. Returns a new sorted stream.",category:"basics"},{id:25,question:"How do lambda expressions improve code readability?",answer:"Lambda expressions reduce boilerplate code, make intent clearer, and enable functional programming style. Compare: list.forEach(item -> System.out.println(item)) vs traditional for-each loops. They make code more concise, expressive, and enable method chaining for fluent APIs.",category:"basics"},{id:26,question:"What is the flatMap() operation in streams?",answer:"flatMap() is an intermediate operation that flattens nested structures. It takes a Function that returns a Stream and flattens the result into a single stream. Example: stream.flatMap(Collection::stream) flattens a stream of collections. It's one-to-many transformation followed by flattening.",category:"intermediate"},{id:27,question:"What are Collectors in Java 8?",answer:"Collectors are utility implementations of the Collector interface used with collect() operation. Common ones: toList(), toSet(), toMap(), groupingBy(), partitioningBy(), joining(), counting(), summarizingInt(). They provide predefined ways to accumulate stream elements into various data structures.",category:"intermediate"},{id:28,question:"How does groupingBy() collector work?",answer:"groupingBy() groups stream elements by a classifier function into a Map. Forms: groupingBy(classifier), groupingBy(classifier, downstream), groupingBy(classifier, mapFactory, downstream). Example: stream.collect(groupingBy(Person::getAge)) groups people by age into Map<Integer, List<Person>>.",category:"intermediate"},{id:29,question:"What is partitioningBy() collector?",answer:"partitioningBy() is a specialized groupingBy that partitions elements based on a Predicate into a Map<Boolean, List<T>>. True key contains matching elements, false key contains non-matching. Example: stream.collect(partitioningBy(n -> n > 10)) separates numbers greater than 10.",category:"intermediate"},{id:30,question:"How do you perform multiple operations with collectors?",answer:"Use downstream collectors with groupingBy/partitioningBy for complex operations. Examples: groupingBy(Person::getCity, counting()) counts people per city, groupingBy(Person::getDept, mapping(Person::getName, toList())) collects names by department. Chain collectors for sophisticated data processing.",category:"intermediate"},{id:31,question:"What is the teeing collector in Java 8+?",answer:"teeing() collector (Java 12+) allows performing two different collector operations on the same stream and combining results with a BiFunction. Example: stream.collect(teeing(counting(), summingInt(Item::getPrice), (count, sum) -> new Summary(count, sum))) combines count and sum operations.",category:"intermediate"},{id:32,question:"How do you create custom collectors?",answer:"Create custom collectors using Collector.of() with supplier (creates container), accumulator (adds elements), combiner (merges containers), finisher (transforms result). Example: Collector.of(ArrayList::new, List::add, (l1, l2) -> { l1.addAll(l2); return l1; }, Function.identity()).",category:"intermediate"},{id:33,question:"What are the three forms of reduce() operation?",answer:"1) reduce(BinaryOperator) - returns Optional<T>, 2) reduce(identity, BinaryOperator) - returns T with identity as default, 3) reduce(identity, BiFunction, BinaryOperator) - for mapping and reducing in one step, useful in parallel streams for different types.",category:"intermediate"},{id:34,question:"How do you handle Optional values effectively?",answer:"Use Optional methods: isPresent()/isEmpty() for checking, ifPresent(Consumer) for conditional actions, orElse(default) for defaults, orElseGet(Supplier) for lazy defaults, orElseThrow() for exceptions, map() for transformations, filter() for conditional processing. Avoid get() without checking.",category:"intermediate"},{id:35,question:"What is the difference between orElse() and orElseGet()?",answer:"orElse(value) always evaluates the default value even if Optional has a value. orElseGet(Supplier) only evaluates the supplier if Optional is empty. Use orElseGet() when default value creation is expensive or has side effects. orElse() for simple constant values.",category:"intermediate"},{id:36,question:"How do you chain Optional operations?",answer:'Chain Optional operations using map(), flatMap(), filter(): optional.map(String::toUpperCase).filter(s -> s.length() > 5).orElse(""). Use flatMap() when mapping function returns Optional. This creates fluent, null-safe processing pipelines without explicit null checks.',category:"intermediate"},{id:37,question:"What are the performance considerations for streams?",answer:"Streams have overhead for simple operations but excel for complex processing. Consider: short-circuiting operations (limit, findFirst), lazy evaluation benefits, boxing costs with primitive streams, parallel stream overhead. Use appropriate stream type (Stream vs IntStream) and benchmark for performance-critical code.",category:"intermediate"},{id:38,question:"How do you convert between different collection types using streams?",answer:"Use collect() with appropriate collectors: stream.collect(toList()), collect(toSet()), collect(toCollection(TreeSet::new)), collect(toMap(keyMapper, valueMapper)). For arrays: stream.toArray() or stream.toArray(String[]::new). Streams provide flexible collection conversion.",category:"intermediate"},{id:39,question:"What is the joining() collector and how is it used?",answer:'joining() collector concatenates stream elements into a String. Forms: joining() (no delimiter), joining(delimiter), joining(delimiter, prefix, suffix). Example: stream.collect(joining(", ", "[", "]")) creates "[a, b, c]". Works with toString() of elements.',category:"intermediate"},{id:40,question:"How do you work with statistical collectors?",answer:"Statistical collectors provide summary statistics: summingInt(), averagingInt(), summarizingInt() return IntSummaryStatistics with count, sum, min, max, average. Example: stream.collect(summarizingInt(Person::getAge)) provides comprehensive age statistics. Available for int, long, double types.",category:"intermediate"},{id:41,question:"What is the collectingAndThen() collector?",answer:"collectingAndThen() applies a finishing transformation to collector result. Takes a collector and finisher function. Example: stream.collect(collectingAndThen(toList(), Collections::unmodifiableList)) creates immutable list. Useful for post-processing collected results.",category:"intermediate"},{id:42,question:"How do you perform multi-level grouping?",answer:"Use nested groupingBy collectors: stream.collect(groupingBy(Person::getDept, groupingBy(Person::getLevel))) creates Map<Dept, Map<Level, List<Person>>>. Can chain multiple levels and combine with other downstream collectors for complex hierarchical data structures.",category:"intermediate"},{id:43,question:"What are the min() and max() operations in streams?",answer:"min() and max() are terminal operations that return Optional<T> with minimum/maximum element using provided Comparator. Return Optional.empty() for empty streams. Example: stream.min(Comparator.comparing(Person::getAge)) finds youngest person. Use natural ordering with min()/max() on Comparable types.",category:"intermediate"},{id:44,question:"How do you handle exceptions in stream operations?",answer:"Streams don't handle checked exceptions well. Strategies: 1) Wrap in unchecked exceptions, 2) Use Optional to represent failures, 3) Create utility methods that handle exceptions, 4) Use try-catch within lambda and return default values. Consider using libraries like Vavr for better exception handling.",category:"intermediate"},{id:45,question:"What is the peek() operation and when should you use it?",answer:"peek() is an intermediate operation for debugging and side effects without affecting stream elements. Takes Consumer<T> and returns same stream. Example: stream.peek(System.out::println).filter(...) logs elements. Use sparingly as it can impact performance and violates functional programming principles.",category:"intermediate"},{id:46,question:"How do you create infinite streams in Java 8?",answer:"Create infinite streams using: Stream.iterate(seed, function) for iterative generation, Stream.generate(supplier) for independent generation. Examples: Stream.iterate(0, n -> n + 1) creates natural numbers, Stream.generate(Math::random) creates random numbers. Always use limit() to avoid infinite processing.",category:"intermediate"},{id:47,question:"What is the difference between Collection and Stream?",answer:"Collections store data in memory and allow multiple traversals. Streams are computed on-demand, support only one-time traversal, and focus on computation rather than storage. Collections are eagerly constructed, streams are lazy. Streams enable functional processing pipelines while collections provide data storage.",category:"intermediate"},{id:48,question:"How do you convert streams to arrays?",answer:"Convert streams to arrays using: toArray() returns Object[], toArray(IntFunction<A[]>) returns typed array. Examples: stream.toArray(String[]::new) for String array, stream.mapToInt(Integer::intValue).toArray() for int array. Use appropriate method reference for desired array type.",category:"intermediate"},{id:49,question:"What are method references and their types?",answer:"Method references are shortcuts for lambda expressions that call existing methods. Types: 1) Static method: Class::staticMethod, 2) Instance method of specific object: object::instanceMethod, 3) Instance method of arbitrary object: Class::instanceMethod, 4) Constructor: Class::new. More readable than equivalent lambdas.",category:"intermediate"},{id:50,question:"How do you use Comparator.comparing() effectively?",answer:"Comparator.comparing() creates comparators from key extraction functions. Chain with thenComparing() for multiple criteria: Comparator.comparing(Person::getLastName).thenComparing(Person::getFirstName). Use reversed() for descending order. Supports nullsFirst()/nullsLast() for null handling.",category:"intermediate"},{id:51,question:"What are parallel streams and how do they work?",answer:"Parallel streams use ForkJoinPool to split work across multiple threads. Create with parallelStream() or parallel(). They decompose, process in parallel, and combine results. Best for CPU-intensive operations on large datasets. Use sequential() to switch back. Performance depends on data size, operation complexity, and available cores.",category:"expert"},{id:52,question:"When should you use parallel streams?",answer:"Use parallel streams when: 1) Large datasets (thousands+ elements), 2) CPU-intensive operations, 3) Independent operations (no shared mutable state), 4) Easily decomposable data structures (ArrayList, arrays). Avoid for: small datasets, I/O operations, operations with side effects, or when ordering matters.",category:"expert"},{id:53,question:"What is the CompletableFuture class?",answer:"CompletableFuture enables asynchronous programming and represents a computation that may complete in the future. Provides methods for chaining, combining, and handling async operations: thenApply(), thenCompose(), thenCombine(), exceptionally(). Supports both sync and async execution modes with optional custom executors.",category:"expert"},{id:54,question:"How do you create CompletableFuture instances?",answer:"Create CompletableFuture using: runAsync(Runnable) for void tasks, supplyAsync(Supplier) for value-returning tasks, completedFuture(value) for already-completed futures. Optional executor parameter for custom thread pools. CompletableFuture.allOf() and anyOf() for multiple futures.",category:"expert"},{id:55,question:"What is the difference between thenApply() and thenCompose()?",answer:"thenApply() transforms result of CompletableFuture using Function<T,R>, returning CompletableFuture<R>. thenCompose() is for chaining operations where function returns CompletableFuture<R>, flattening nested futures. Similar to map vs flatMap in streams. Use thenCompose() to avoid CompletableFuture<CompletableFuture<T>>.",category:"expert"},{id:56,question:"How do you handle exceptions in CompletableFuture?",answer:"Handle exceptions using: exceptionally(Function) for recovery, handle(BiFunction) for result and exception, whenComplete(BiConsumer) for side effects. Chain exception handling: future.thenApply(...).exceptionally(ex -> defaultValue). Use completeExceptionally() to propagate exceptions manually.",category:"expert"},{id:57,question:"What is the new Date and Time API in Java 8?",answer:"Java 8 introduced java.time package with immutable date-time classes: LocalDate, LocalTime, LocalDateTime (no timezone), ZonedDateTime (with timezone), Instant (timestamps), Duration and Period (time amounts). Replaces problematic Date and Calendar with thread-safe, fluent API.",category:"expert"},{id:58,question:"How do you work with LocalDate, LocalTime, and LocalDateTime?",answer:"LocalDate for dates (2023-12-25): LocalDate.now(), LocalDate.of(2023,12,25), plusDays(), minusMonths(). LocalTime for times (14:30): LocalTime.now(), LocalTime.of(14,30). LocalDateTime combines both: LocalDateTime.now(), atDate(), atTime(). All are immutable with fluent APIs.",category:"expert"},{id:59,question:"What is the difference between Instant and LocalDateTime?",answer:"Instant represents a point on the timeline (UTC timestamp), suitable for machine processing and logging. LocalDateTime represents date-time without timezone, suitable for human-readable dates. Instant is absolute, LocalDateTime is relative to timezone. Convert using atZone(), toInstant() methods.",category:"expert"},{id:60,question:"How do you work with timezones in Java 8?",answer:'Use ZonedDateTime for timezone-aware dates: ZonedDateTime.now(ZoneId.of("America/New_York")). ZoneId represents timezones, ZoneOffset for fixed offsets. Convert between timezones using withZoneSameInstant(). OffsetDateTime for UTC offset without timezone rules.',category:"expert"},{id:61,question:"What are DateTimeFormatter and parsing in Java 8?",answer:'DateTimeFormatter formats and parses dates with predefined patterns (ISO_LOCAL_DATE) or custom patterns ("yyyy-MM-dd HH:mm:ss"). Use format() to convert to string, parse() to convert from string. Example: LocalDate.parse("2023-12-25", DateTimeFormatter.ISO_LOCAL_DATE). Immutable and thread-safe.',category:"expert"},{id:62,question:"What is the Stream.iterate() vs Stream.generate() difference?",answer:"iterate(seed, function) creates sequential infinite stream by applying function to previous element: Stream.iterate(0, n -> n + 1). generate(supplier) creates infinite stream by calling supplier repeatedly: Stream.generate(Math::random). iterate is stateful, generate is stateless.",category:"expert"},{id:63,question:"How do you configure parallel stream thread pool?",answer:"Parallel streams use common ForkJoinPool by default. Configure using system property: -Djava.util.concurrent.ForkJoinPool.common.parallelism=4. For custom thread pool, use CompletableFuture.supplyAsync() with custom executor instead of parallel streams. Common pool size defaults to processor count - 1.",category:"expert"},{id:64,question:"What are the characteristics of good parallel stream operations?",answer:"Good parallel operations are: 1) Independent (no shared mutable state), 2) Stateless, 3) Non-interfering with data source, 4) Computationally expensive enough to justify overhead, 5) Work well with spliterators for data decomposition. Operations like filter, map work well; collect, findFirst may not.",category:"expert"},{id:65,question:"What is Spliterator and how does it relate to parallel streams?",answer:"Spliterator (splittable iterator) enables parallel processing by splitting data sources. It has characteristics like ORDERED, DISTINCT, SORTED, SIZED that help optimize operations. Good spliterators (ArrayList) enable efficient parallelization, poor ones (LinkedList) don't split well. Used internally by parallel streams.",category:"expert"},{id:66,question:"How do you combine multiple CompletableFutures?",answer:"Combine CompletableFutures using: thenCombine(other, BiFunction) for dependent results, allOf(futures...) waits for all, anyOf(futures...) waits for first completion. Use thenAcceptBoth() for consuming two results, runAfterBoth() for actions after both complete. Chain multiple combinations for complex workflows.",category:"expert"},{id:67,question:"What is the Base64 API in Java 8?",answer:'Java 8 added built-in Base64 support with Base64 class. Three encoders: basic (RFC 4648), URL-safe (RFC 4648 Section 5), MIME (RFC 2045). Methods: getEncoder().encodeToString(), getDecoder().decode(). Example: Base64.getEncoder().encodeToString("text".getBytes()).',category:"expert"},{id:68,question:"What are the performance implications of boxing in streams?",answer:"Boxing/unboxing between primitives and wrapper classes creates performance overhead. Use specialized streams (IntStream, LongStream, DoubleStream) for primitive operations. Methods mapToInt(), mapToLong(), mapToDouble() convert to primitive streams. Primitive streams provide sum(), average(), max() without boxing.",category:"expert"},{id:69,question:"How do you debug stream operations effectively?",answer:"Debug streams using: 1) peek() for inspecting elements, 2) Breaking complex chains into steps, 3) Using intermediate variables, 4) Adding logging within lambdas, 5) IDE debugger support for stream operations. Consider extracting lambdas to named methods for better stack traces and debugging.",category:"expert"},{id:70,question:"What are the best practices for using Java 8 features?",answer:"Best practices: 1) Prefer method references over lambdas when possible, 2) Keep lambdas short and focused, 3) Use appropriate functional interfaces, 4) Avoid side effects in stream operations, 5) Use Optional to avoid null checks, 6) Choose sequential vs parallel streams based on data and operations, 7) Leverage specialized primitive streams.",category:"expert"},{id:71,question:"What is the difference between Collection.stream() and Collection.parallelStream()?",answer:"stream() creates sequential stream processed by current thread. parallelStream() creates parallel stream using ForkJoinPool for concurrent processing. Parallel streams split data, process chunks in parallel, then combine results. Choose based on data size, operation complexity, and performance requirements.",category:"expert"},{id:72,question:"How do you create custom functional interfaces?",answer:"Create functional interfaces with @FunctionalInterface annotation and exactly one abstract method. Can have default and static methods. Example: @FunctionalInterface interface Calculator { int calculate(int a, int b); default int square(int x) { return x * x; } }. Used with lambdas for specific domain logic.",category:"expert"},{id:73,question:"What are the common pitfalls when using parallel streams?",answer:"Pitfalls: 1) Using with small datasets (overhead exceeds benefits), 2) Shared mutable state causing race conditions, 3) Stateful operations breaking parallelism, 4) I/O operations blocking threads, 5) Incorrect assumptions about ordering, 6) Using with poorly splittable data structures. Always measure performance.",category:"expert"},{id:74,question:"How do you work with Duration and Period in Java 8?",answer:"Duration represents time-based amounts (hours, minutes, seconds): Duration.ofHours(2), duration.toMinutes(). Period represents date-based amounts (years, months, days): Period.ofDays(30), period.getMonths(). Use between() to calculate differences: Duration.between(start, end), Period.between(date1, date2).",category:"expert"},{id:75,question:"What are the memory considerations for stream operations?",answer:"Stream considerations: 1) Intermediate operations are lazy (low memory), 2) collect() operations may require significant memory, 3) sorted() requires full materialization, 4) Infinite streams need limit(), 5) Parallel streams use additional memory for work-stealing, 6) Large collectors like groupingBy() can consume substantial memory.",category:"expert"}],a=[{id:1,question:"What is the syntax for a simple lambda expression that adds two numbers?",options:["(x, y) => x + y","(x, y) -> x + y","x, y -> x + y","lambda x, y: x + y"],correctAnswer:1,category:"basics"},{id:2,question:"Which annotation is used to mark functional interfaces?",options:["@Functional","@FunctionalInterface","@Lambda","@Interface"],correctAnswer:1,category:"basics"},{id:3,question:"How many abstract methods can a functional interface have?",options:["Zero","Exactly one","One or more","Any number"],correctAnswer:1,category:"basics"},{id:4,question:"Which functional interface represents a function that takes one argument and returns a result?",options:["Consumer<T>","Supplier<T>","Function<T,R>","Predicate<T>"],correctAnswer:2,category:"basics"},{id:5,question:"What does the Predicate<T> functional interface represent?",options:["T -> void","() -> T","T -> R","T -> boolean"],correctAnswer:3,category:"basics"},{id:6,question:"Which method reference type is List::size?",options:["Static method reference","Instance method of arbitrary object","Instance method of specific object","Constructor reference"],correctAnswer:1,category:"basics"},{id:7,question:"What is the result of Stream.of(1,2,3,4).filter(x -> x > 2).count()?",options:["1","2","3","4"],correctAnswer:1,category:"basics"},{id:8,question:"Which operation is NOT a terminal operation?",options:["forEach","collect","map","reduce"],correctAnswer:2,category:"basics"},{id:9,question:"How do you create an empty Optional?",options:["new Optional()","Optional.null()","Optional.empty()","Optional.of(null)"],correctAnswer:2,category:"basics"},{id:10,question:"What happens when you call Optional.of(null)?",options:["Returns empty Optional","Returns Optional with null value","Throws NullPointerException","Compilation error"],correctAnswer:2,category:"basics"},{id:11,question:"Which method should you use to safely create an Optional that might be null?",options:["Optional.of()","Optional.empty()","Optional.ofNullable()","Optional.nullable()"],correctAnswer:2,category:"basics"},{id:12,question:"What is the purpose of default methods in interfaces?",options:["Provide default values","Enable interface evolution","Improve performance","Replace abstract methods"],correctAnswer:1,category:"basics"},{id:13,question:"How do you create a stream from a collection?",options:["collection.toStream()","Stream.of(collection)","collection.stream()","new Stream(collection)"],correctAnswer:2,category:"basics"},{id:14,question:"What does the map() operation do in streams?",options:["Filters elements","Transforms elements","Sorts elements","Counts elements"],correctAnswer:1,category:"basics"},{id:15,question:"Which stream operation would you use to remove duplicates?",options:["filter()","distinct()","unique()","dedupe()"],correctAnswer:1,category:"basics"},{id:16,question:"What is the return type of stream.collect(Collectors.toList())?",options:["Stream<List>","Optional<List>","List","Collection"],correctAnswer:2,category:"basics"},{id:17,question:"Which operation limits the stream to the first n elements?",options:["take(n)","limit(n)","first(n)","head(n)"],correctAnswer:1,category:"basics"},{id:18,question:"What does IntStream provide that Stream<Integer> doesn't?",options:["Better performance","More methods","Primitive operations","All of the above"],correctAnswer:3,category:"basics"},{id:19,question:"How do you convert a Stream<String> to IntStream?",options:["mapToInt()","asInt()","toIntStream()","convertInt()"],correctAnswer:0,category:"basics"},{id:20,question:"What is the difference between findFirst() and findAny()?",options:["No difference","findFirst() is for sequential, findAny() for parallel","findFirst() returns first element, findAny() any element","findAny() is deprecated"],correctAnswer:2,category:"basics"},{id:21,question:"Which matching operation returns true if all elements satisfy the predicate?",options:["anyMatch()","allMatch()","noneMatch()","fullMatch()"],correctAnswer:1,category:"basics"},{id:22,question:"What does the skip(n) operation do?",options:["Skips every nth element","Skips the first n elements","Skips the last n elements","Skips n random elements"],correctAnswer:1,category:"basics"},{id:23,question:"How do you sort a stream in descending order by natural ordering?",options:["sorted(descending())","sorted(Comparator.reversed())","sorted(Collections.reverseOrder())","sorted().reverse()"],correctAnswer:2,category:"basics"},{id:24,question:"What is lazy evaluation in streams?",options:["Slow processing","Operations execute only when terminal operation is called","Delayed method calls","Caching results"],correctAnswer:1,category:"basics"},{id:25,question:"Which lambda expression is equivalent to System.out::println?",options:["() -> System.out.println()","x -> System.out.println()","x -> System.out.println(x)","System.out.println()"],correctAnswer:2,category:"basics"},{id:26,question:"What does flatMap() do in streams?",options:["Flattens nested collections","Maps and filters simultaneously","Creates 2D mappings","Reduces dimensions"],correctAnswer:0,category:"intermediate"},{id:27,question:"How do you group elements by a property using collectors?",options:["groupBy()","groupingBy()","collect()","partition()"],correctAnswer:1,category:"intermediate"},{id:28,question:"What is the result type of Collectors.groupingBy(Person::getAge)?",options:["List<Person>","Map<Integer, Person>","Map<Integer, List<Person>>","Set<Person>"],correctAnswer:2,category:"intermediate"},{id:29,question:"Which collector partitions elements based on a boolean predicate?",options:["partitioningBy()","groupingBy()","separatingBy()","dividingBy()"],correctAnswer:0,category:"intermediate"},{id:30,question:"What does the joining() collector do?",options:["Joins two streams","Concatenates elements into a string","Merges collections","Combines results"],correctAnswer:1,category:"intermediate"},{id:31,question:"How do you count elements while grouping?",options:["groupingBy(classifier, count())","groupingBy(classifier, counting())","groupingBy(classifier).count()","countingBy(classifier)"],correctAnswer:1,category:"intermediate"},{id:32,question:"What is the difference between reduce() forms?",options:["No difference","Different parameter counts","Different return types","Both B and C"],correctAnswer:3,category:"intermediate"},{id:33,question:"Which method should you use instead of Optional.get()?",options:["Optional.value()","Optional.orElse()","Optional.retrieve()","Optional.extract()"],correctAnswer:1,category:"intermediate"},{id:34,question:"When should you use orElseGet() instead of orElse()?",options:["Never","When default value creation is expensive","When value is null","Always"],correctAnswer:1,category:"intermediate"},{id:35,question:"How do you chain Optional operations?",options:["Using if-else","Using map() and flatMap()","Using get() and set()","Cannot be chained"],correctAnswer:1,category:"intermediate"},{id:36,question:"What does Optional.filter() do?",options:["Filters the Optional value","Returns filtered Optional","Both A and B","Throws exception"],correctAnswer:2,category:"intermediate"},{id:37,question:"Which collector converts to a different collection type?",options:["toList()","toCollection()","toSet()","All of the above"],correctAnswer:1,category:"intermediate"},{id:38,question:"How do you get summary statistics for integers in a stream?",options:["summarizing()","summarizingInt()","summaryStats()","statisticsInt()"],correctAnswer:1,category:"intermediate"},{id:39,question:"What does collectingAndThen() do?",options:["Collects and transforms result","Collects in sequence","Collects and terminates","Collects conditionally"],correctAnswer:0,category:"intermediate"},{id:40,question:"How do you perform multi-level grouping?",options:["Use multiple collect() calls","Use nested groupingBy()","Use groupBy() twice","Not possible"],correctAnswer:1,category:"intermediate"},{id:41,question:"What is the purpose of peek() operation?",options:["Debug and inspect elements","Transform elements","Filter elements","Count elements"],correctAnswer:0,category:"intermediate"},{id:42,question:"How do you create an infinite stream of random numbers?",options:["Stream.infinite(Math::random)","Stream.generate(Math::random)","Stream.random()","Stream.iterate(Math::random)"],correctAnswer:1,category:"intermediate"},{id:43,question:"What is the difference between Stream.iterate() and Stream.generate()?",options:["No difference","iterate() is sequential, generate() is stateless","generate() is deprecated","iterate() is for numbers only"],correctAnswer:1,category:"intermediate"},{id:44,question:"How do you convert a stream to an array?",options:["stream.asArray()","stream.toArray()","stream.array()","stream.collect(toArray())"],correctAnswer:1,category:"intermediate"},{id:45,question:"Which is the correct way to handle exceptions in streams?",options:["Use try-catch in lambda","Wrap in runtime exception","Use Optional for failures","All of the above"],correctAnswer:3,category:"intermediate"},{id:46,question:"What does Comparator.comparing() return?",options:["boolean","int","Comparator","Comparable"],correctAnswer:2,category:"intermediate"},{id:47,question:"How do you chain multiple comparison criteria?",options:["Use multiple comparing()","Use thenComparing()","Use andComparing()","Use addComparing()"],correctAnswer:1,category:"intermediate"},{id:48,question:"What happens if you call a terminal operation twice on the same stream?",options:["Works normally","Returns cached result","Throws IllegalStateException","Returns empty result"],correctAnswer:2,category:"intermediate"},{id:49,question:"How do you reverse a comparator?",options:["Comparator.reverse()","comparator.reversed()","Collections.reverse(comparator)","comparator.invert()"],correctAnswer:1,category:"intermediate"},{id:50,question:"What is the purpose of downstream collectors?",options:["Process grouped data further","Improve performance","Handle errors","Sort results"],correctAnswer:0,category:"intermediate"},{id:51,question:"When should you use parallel streams?",options:["Always for better performance","For small datasets","For large datasets with CPU-intensive operations","Never"],correctAnswer:2,category:"expert"},{id:52,question:"Which data structure is best for parallel stream performance?",options:["LinkedList","ArrayList","TreeSet","HashMap"],correctAnswer:1,category:"expert"},{id:53,question:"How do you create a CompletableFuture that returns a value?",options:["CompletableFuture.runAsync()","CompletableFuture.supplyAsync()","CompletableFuture.completedFuture()","new CompletableFuture()"],correctAnswer:1,category:"expert"},{id:54,question:"What is the difference between thenApply() and thenCompose()?",options:["No difference","thenApply() for transformation, thenCompose() for chaining","thenCompose() is deprecated","thenApply() is synchronous"],correctAnswer:1,category:"expert"},{id:55,question:"How do you handle exceptions in CompletableFuture?",options:["try-catch blocks","exceptionally() method","handle() method","Both B and C"],correctAnswer:3,category:"expert"},{id:56,question:"Which class represents a date without time zone?",options:["ZonedDateTime","LocalDateTime","Instant","OffsetDateTime"],correctAnswer:1,category:"expert"},{id:57,question:"What is the difference between Duration and Period?",options:["No difference","Duration for time-based, Period for date-based","Period is deprecated","Duration is more precise"],correctAnswer:1,category:"expert"},{id:58,question:"How do you format a LocalDate?",options:["date.format(pattern)","DateTimeFormatter.format(date)","date.format(DateTimeFormatter)","format(date, pattern)"],correctAnswer:2,category:"expert"},{id:59,question:"Which represents an absolute point in time?",options:["LocalDateTime","ZonedDateTime","Instant","OffsetDateTime"],correctAnswer:2,category:"expert"},{id:60,question:"How do you configure parallel stream thread pool size?",options:["Stream.setParallelism()","System property","ForkJoinPool.setParallelism()","Runtime.setThreads()"],correctAnswer:1,category:"expert"},{id:61,question:"What is Spliterator used for?",options:["Splitting collections","Parallel stream processing","Iterator enhancement","All of the above"],correctAnswer:3,category:"expert"},{id:62,question:"How do you combine two CompletableFutures?",options:["thenCombine()","thenMerge()","thenJoin()","thenUnion()"],correctAnswer:0,category:"expert"},{id:63,question:"What does CompletableFuture.allOf() do?",options:["Waits for all futures to complete","Combines all results","Returns first completed","Cancels all futures"],correctAnswer:0,category:"expert"},{id:64,question:"Which Java 8 feature provides Base64 encoding?",options:["java.util.Base64","java.security.Base64","java.nio.Base64","java.encoding.Base64"],correctAnswer:0,category:"expert"},{id:65,question:"What is the main advantage of primitive streams?",options:["Simpler syntax","No boxing/unboxing overhead","Better readability","More methods"],correctAnswer:1,category:"expert"},{id:66,question:"How do you debug complex stream operations?",options:["Use peek()","Break into steps","Add logging","All of the above"],correctAnswer:3,category:"expert"},{id:67,question:"What is a common pitfall with parallel streams?",options:["Using with small datasets","Shared mutable state","I/O operations","All of the above"],correctAnswer:3,category:"expert"},{id:68,question:"How do you create a custom functional interface?",options:["@FunctionalInterface with one abstract method","@Lambda annotation","extends Function","implements Functional"],correctAnswer:0,category:"expert"},{id:69,question:"What does the @FunctionalInterface annotation do?",options:["Makes interface functional","Enables lambda usage","Ensures single abstract method","Improves performance"],correctAnswer:2,category:"expert"},{id:70,question:"Which operation requires full stream materialization?",options:["filter()","map()","sorted()","limit()"],correctAnswer:2,category:"expert"},{id:71,question:"How do you calculate time between two LocalDateTime instances?",options:["Duration.between()","Period.between()","ChronoUnit.between()","Both A and C"],correctAnswer:3,category:"expert"},{id:72,question:"What is the ForkJoinPool used for?",options:["Sequential processing","Parallel stream execution","Thread management","Both B and C"],correctAnswer:3,category:"expert"},{id:73,question:"How do you handle timezone conversion?",options:["withZoneSameInstant()","toZone()","convertZone()","setTimeZone()"],correctAnswer:0,category:"expert"},{id:74,question:"What is the difference between sequential() and parallel() on streams?",options:["Performance only","Changes execution mode","No difference","Changes result type"],correctAnswer:1,category:"expert"},{id:75,question:"How do you ensure thread safety with CompletableFuture?",options:["Use synchronized","Use locks","CompletableFuture is thread-safe","Use volatile"],correctAnswer:2,category:"expert"}];export{e as categoryData,t as flashcards,a as quizQuestions};
//# sourceMappingURL=data-CGULwEQp.js.map
